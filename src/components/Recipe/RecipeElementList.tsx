import React, {useEffect, useState, useCallback} from "react";
import {useDataFetcher} from "../../hooks/useDataFetcher.ts";
import type {RecipeElement} from "../../models/IRecipeElement.ts";
import RecipeIngredientForm from "../RecipeIngredient/RecipeIngredientForm.tsx";
import {useAuth} from "react-oidc-context";
import useFlash from "../../contexts/FlashContext.tsx";
import RecipeLabourForm from "../RecipeLabour/RecipeLabourForm.tsx"
import type {IGenericFormProps} from "../../models/IFormProps.ts";
import {patchField} from "../../services/commonService.ts";
import RecipeSubRecipeForm from "../RecipeSubRecipe/RecipeSubRecipeForm.tsx";

interface RecipeElementListProps {
    recipe_id: number; // Using camelCase convention
    refetchData: number;
}

const RecipeElementList = ({recipe_id, refetchTrigger}: RecipeElementListProps) => {

    const auth = useAuth();
    const {showFlashMessage} = useFlash();



    const componentMap: { [key: string]: React.ComponentType<any> } = {
        ingredient: RecipeIngredientForm,
        labour: RecipeLabourForm,
        subrecipe: RecipeSubRecipeForm,
        // anon
    }
    // map of endpoints to element types.  All endpoints are created in the same format - patch and delete functions
    // just need to know the endpoint to go to.  todo - these are used repeatedly throughout the app - should they
    // be centralised?  should i be using a link to a swagger file generated by fastapi to tie it all toghether?
    const apiEndpointMap: { [key: string]: string } = {
        ingredient: 'recipe_ingredient',
        labour: 'recipe_labour',
        subrecipe: 'recipe_sub_recipe',
        // anon
        // energy: 'recipe_energy', etc
    };

    // endpoint to fetch all the heterogeneous list of recipe elements
    const endpointToFetch = (recipe_id && recipe_id > 0)
        ? `/recipe/${recipe_id}/elements`
        : null;


    const {
        data: fetchedElements,  // single point of truth for the entire list and its child elements
        loading,  // bool
        error,  // string- currently too much detail - todo - tidy this up in the context definition
        refetch,  // callback - triggers a refetch of the data
    } = useDataFetcher<RecipeElement[]>(endpointToFetch);


    const [recipeElements, setRecipeElements] = useState([]);


    // ---  sync Server State to UI State ---
    useEffect(() => {
        if (fetchedElements) {
            // Sort the data when it's first loaded or refetched
            const sortedElements = [...fetchedElements].sort((a, b) => a.data.sort_order - b.data.sort_order);
            setRecipeElements(sortedElements);
        }
    }, [fetchedElements]); // This runs whenever the data from the server changes


    // Allow parent to trigger a refetch
    useEffect(() => {
        if (recipe_id > 0) {
            refetch();
        }
    }, [refetchTrigger, refetch, recipe_id]);


    const handleChange = useCallback((id: number, elementType: string, fieldName: string, value: any) => {
        // Optimistically update the local UI state on every keystroke
        setRecipeElements(currentList =>
            currentList.map(item =>
                // Check both id and type to ensure we're updating the correct element
                item.data.id === id && item.element_type === elementType
                    // Correctly update the nested 'data' object
                    ? { ...item, data: { ...item.data, [fieldName]: value } }
                    : item
            )
        );
    }, []);

    const handleEdit = useCallback(async (id: number, elementType: string, fieldName: string, value: any, originalValue: any) => {
        //  check to see if the value has actually changed when loses focus.  todo - this logic is repeated somewhere - find and consolidate logic
        if (String(value) === String(originalValue)) {
            return; // Do nothing if the value is the same as when it was focused
        }

        if (!auth.user?.access_token) return;
        const apiEndpoint = apiEndpointMap[elementType];
        if (!apiEndpoint) {
            showFlashMessage(`Unknown element type: ${elementType}`, 'danger');
            return;
        }
        try {
            await patchField(auth.user.access_token, id, fieldName, value, apiEndpoint);
            showFlashMessage('Saved!', 'success', 1000); // Brief success message
        } catch (err) {
            showFlashMessage(err instanceof Error ? err.message : 'Failed to save changes', 'danger');
            refetch(); // Revert optimistic UI on failure by refetching server state
        }
    }, [apiEndpointMap, refetch, auth, showFlashMessage]);

    const handleDelete = useCallback(async (id: number, elementType: string) => {
        console.log(`Deleting ${elementType} with id ${id}`);
        // rthink i have this declared in the delete component so no need for this here
        refetch();
    }, [refetch]);


    // --- State Handling Logic ---

    // 1. Handle the loading state first.
    //    Show a spinner only on the initial load.
    if (loading && !recipeElements) {
        return <p>Loading recipe steps...</p>;
    }

    // 2. Handle any errors that occurred during fetching.  // todo - remove error after testing
    if (error) {
        return <div className="notification is-danger">Error loading recipe steps: {error}</div>;
    }

    // 3. Handle the case where the fetch was successful but returned no data.
    if (!recipeElements || recipeElements.length === 0) {
        return (
            <div className="box">
                <p>This recipe has no ingredients or labour steps defined yet.</p>
            </div>
        );
    }

    // 4. If we get here, we have data to render.
    return (
        <div className="box">
            <h3 className="title is-5">Recipe Elements {recipeElements?.length}</h3>
            {recipeElements.map(element => {
                const key = `${element.element_type}-${element.data.id}`;
                const ElementComponent = componentMap[element.element_type];

                const elementProps: IGenericFormProps<any> = {
                    formData: element.data,
                    onSave: () => {}, // stub does nothing as form will never be in isNew ==true state
                    // on change default in the form is to return fieldName and value, need to add the id and type to tell the
                    // handle change function which endpoint to send the patch to, and for whcih ID
                    onChange: (fieldName, value) => handleChange(element.data.id, element.element_type, fieldName, value),
                    // The child form's `onEdit` calls this function with (fieldName, value)
                    onEdit: (fieldName, value) => handleEdit(element.data.id, element.element_type, fieldName, value),
                    // The child form's `onDelete` calls this function with no arguments
                    onDelete: () => handleDelete(element.data.id, element.element_type),
                    onCancel: () => {
                    }, // stub does nothing as form will never be in isNew ==true state
                    isSaving: false,
                    isModal: false
                }
                return (
                    <ElementComponent
                        key={key}
                        {...elementProps}  // spread props - this is how the form types are set to expect props
                    />

                )
            })}
        </div>
    );
};

export default RecipeElementList;